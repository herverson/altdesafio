# AltForce - Sistema de Or√ßamentos Din√¢micos

Sistema de or√ßamentos com formul√°rios din√¢micos, engine de regras configur√°veis e arquitetura OOP avan√ßada desenvolvido em Flutter.

## üìä Diagrama de Classes (Hierarquias OOP)

```
diagrama de classes.png
```

## üß¨ Documenta√ß√£o de Gen√©ricos e Constraints

### üîß Gen√©ricos Type-Safe Implementados

#### 1. **Repository Pattern com Constraints**
```dart
// Interface gen√©rica com constraint de BaseModel
abstract class IRepository<T extends BaseModel> {
  Future<Result<List<T>>> findAll();
  Future<Result<T?>> findById(String id);
  Future<Result<T>> save(T item);
}

// Implementa√ß√£o gen√©rica
class MemoryRepository<T extends BaseModel> implements IRepository<T> {
  final Map<String, T> _storage = {};
  
  // M√©todos garantem type safety em tempo de compila√ß√£o
  @override
  Future<Result<T>> save(T item) async {
    _storage[item.id] = item; // ‚úÖ item.id garantido pelo constraint
    return Result.success(item);
  }
}
```

**Benef√≠cios:**
- ‚úÖ **Type Safety**: Apenas tipos que estendem `BaseModel` s√£o aceitos
- ‚úÖ **Intellisense**: IDE fornece autocompletar correto
- ‚úÖ **Erro em Compila√ß√£o**: Tipos incorretos s√£o rejeitados antes da execu√ß√£o
- ‚úÖ **Reutiliza√ß√£o**: Um repository para qualquer modelo

#### 2. **Form Controller Gen√©rico**
```dart
class FormController<T extends Product> extends ChangeNotifier {
  T? _selectedProduct;
  
  void selectProduct(T product) {
    _selectedProduct = product;
    // ‚úÖ M√©todos de Product garantidos pelo constraint
    _rebuildForm(); // Usa product.getFormFields()
  }
  
  PricingResult calculatePrice() {
    // ‚úÖ Acesso type-safe aos m√©todos do produto
    final basePrice = _selectedProduct!.calculateBasePrice(_formData);
    return _pricingEngine.calculateFinalPrice(basePrice, context);
  }
}
```

**Vantagens:**
- ‚úÖ **Polimorfismo**: Funciona com qualquer tipo de produto
- ‚úÖ **Type Safety**: M√©todos espec√≠ficos de Product dispon√≠veis
- ‚úÖ **Extensibilidade**: Novos tipos de produto funcionam automaticamente

#### 3. **Rules Engine Gen√©rica**
```dart
class RulesEngine<T extends BusinessRule> {
  final List<T> _rules = [];
  
  void addRule(T rule) {
    _rules.add(rule);
    // ‚úÖ rule.priority garantido pelo constraint
    _sortRulesByPriority();
  }
  
  EngineExecutionResult execute(RuleContext context) {
    for (final rule in _rules) {
      // ‚úÖ M√©todos abstratos garantidos
      if (!rule.isApplicable(context)) continue;
      final result = rule.execute(context);
      // ...
    }
  }
}
```

#### 4. **Result Pattern Gen√©rico**
```dart
abstract class Result<T> {
  bool get isSuccess => this is Success<T>;
  T? get data => isSuccess ? (this as Success<T>).data : null;
  
  // Transforma√ß√£o type-safe
  Result<R> map<R>(R Function(T data) transform) {
    if (isSuccess) {
      return Result.success(transform((this as Success<T>).data));
    }
    return Result.failure((this as Failure<T>).error);
  }
}

// Uso pr√°tico
Future<Result<List<Product>>> loadProducts() async {
  final result = await repository.findAll(); // Result<List<Product>>
  return result.map((products) => 
    products.where((p) => p.isValid).toList()
  ); // Ainda Result<List<Product>>
}
```

### üéØ Constraints e Bounded Types

#### **Constraint Hierarchy**
```dart
// Hierarquia de constraints
BaseModel                    // N√≠vel base
  ‚Ü≥ Product                 // Constraint mais espec√≠fico
    ‚Ü≥ IndustrialProduct     // Implementa√ß√£o concreta
    ‚Ü≥ ResidentialProduct    // Implementa√ß√£o concreta
    ‚Ü≥ CorporateProduct      // Implementa√ß√£o concreta
  ‚Ü≥ BusinessRule           // Outro branch
    ‚Ü≥ PricingRule          // Implementa√ß√£o espec√≠fica
    ‚Ü≥ ValidationRule       // Implementa√ß√£o espec√≠fica
```

#### **Vantagens dos Constraints**
1. **Garantia de Interface**: `T extends BaseModel` garante `id` e `name`
2. **M√©todos Dispon√≠veis**: `T extends Product` garante m√©todos de produto
3. **Type Safety**: Compilador verifica compatibilidade
4. **Polimorfismo**: Funciona com toda a hierarquia

### üîç Exemplos Pr√°ticos de Type Safety

```dart
// ‚úÖ CORRETO - Product √© aceito
final controller = FormController<IndustrialProduct>();
controller.selectProduct(IndustrialProduct(...));

// ‚ùå ERRO DE COMPILA√á√ÉO - String n√£o estende Product
final controller = FormController<String>(); // Compilation Error!

// ‚úÖ CORRETO - Repository aceita qualquer BaseModel
final productRepo = MemoryRepository<Product>();
final ruleRepo = MemoryRepository<BusinessRule>();

// ‚ùå ERRO DE COMPILA√á√ÉO - int n√£o estende BaseModel
final invalidRepo = MemoryRepository<int>(); // Compilation Error!
```

## üßπ An√°lise DRY (Don't Repeat Yourself)

### üéØ Como o Projeto Evita Duplica√ß√£o de C√≥digo

#### 1. **Mixins para Funcionalidades Transversais**

**‚ùå ANTES (C√≥digo Duplicado):**
```dart
class IndustrialProduct {
  String formatCurrency(double value) => 'R\$ ${value.toStringAsFixed(2)}';
  bool isPositive(num value) => value > 0;
  double calculateTotal(double price, int qty) => price * qty;
}

class ResidentialProduct {
  String formatCurrency(double value) => 'R\$ ${value.toStringAsFixed(2)}'; // DUPLICADO
  bool isPositive(num value) => value > 0; // DUPLICADO
  double calculateTotal(double price, int qty) => price * qty; // DUPLICADO
}
```

**‚úÖ DEPOIS (DRY com Mixins):**
```dart
// Funcionalidade centralizada em mixins
mixin CalculatorMixin {
  double calculateTotal(double price, int qty) => price * qty;
  bool isPositive(num value) => value > 0;
}

mixin FormatterMixin {
  String formatCurrency(double value) => 'R\$ ${value.toStringAsFixed(2)}';
}

// Reutiliza√ß√£o em todas as classes de produto
class Product extends BaseModel with CalculatorMixin, FormatterMixin {
  // Todos os produtos herdam as funcionalidades sem duplica√ß√£o
}
```

**Benef√≠cios:**
- üîÑ **Reutiliza√ß√£o**: 3 mixins usados por todos os produtos
- üéØ **Manuten√ß√£o**: Altera√ß√£o em 1 local afeta todos os produtos
- üì¶ **Modularidade**: Funcionalidades organizadas por responsabilidade

#### 2. **Repository Pattern Gen√©rico**

**‚ùå ANTES (C√≥digo Duplicado):**
```dart
class ProductRepository {
  final Map<String, Product> _storage = {};
  
  Future<List<Product>> findAll() async => _storage.values.toList();
  Future<Product?> findById(String id) async => _storage[id];
  Future<Product> save(Product item) async {
    _storage[item.id] = item;
    return item;
  }
}

class BusinessRuleRepository {
  final Map<String, BusinessRule> _storage = {}; // DUPLICADO
  
  Future<List<BusinessRule>> findAll() async => _storage.values.toList(); // DUPLICADO
  Future<BusinessRule?> findById(String id) async => _storage[id]; // DUPLICADO
  Future<BusinessRule> save(BusinessRule item) async { // DUPLICADO
    _storage[item.id] = item;
    return item;
  }
}
```

**‚úÖ DEPOIS (DRY com Gen√©ricos):**
```dart
class MemoryRepository<T extends BaseModel> implements IRepository<T> {
  final Map<String, T> _storage = {};
  
  @override
  Future<Result<List<T>>> findAll() async => Result.success(_storage.values.toList());
  
  @override
  Future<Result<T?>> findById(String id) async => Result.success(_storage[id]);
  
  @override
  Future<Result<T>> save(T item) async {
    _storage[item.id] = item;
    return Result.success(item);
  }
}

// Uso sem duplica√ß√£o
final productRepo = MemoryRepository<Product>();
final ruleRepo = MemoryRepository<BusinessRule>();
```

**Economia:**
- üìâ **Redu√ß√£o**: De ~200 linhas duplicadas para 1 classe gen√©rica
- üîß **Manuten√ß√£o**: Bugs corrigidos em 1 lugar para todos os tipos
- üöÄ **Extensibilidade**: Novos tipos funcionam automaticamente

#### 3. **Rules Engine Gen√©rica**

**‚ùå ANTES (Engines Espec√≠ficas Duplicadas):**
```dart
class PricingRulesEngine {
  final List<PricingRule> _rules = [];
  void addRule(PricingRule rule) => _rules.add(rule);
  void removeRule(String id) => _rules.removeWhere((r) => r.id == id);
  // ... l√≥gica de execu√ß√£o duplicada
}

class ValidationRulesEngine {
  final List<ValidationRule> _rules = []; // DUPLICADO
  void addRule(ValidationRule rule) => _rules.add(rule); // DUPLICADO
  void removeRule(String id) => _rules.removeWhere((r) => r.id == id); // DUPLICADO
  // ... mesma l√≥gica de execu√ß√£o
}
```

**‚úÖ DEPOIS (DRY com Engine Gen√©rica):**
```dart
class RulesEngine<T extends BusinessRule> {
  final List<T> _rules = [];
  
  void addRule(T rule) {
    _rules.add(rule);
    _sortRulesByPriority();
  }
  
  EngineExecutionResult execute(RuleContext context) {
    // L√≥gica √∫nica para todos os tipos de regra
    for (final rule in _rules) {
      if (!rule.isApplicable(context)) continue;
      final result = rule.execute(context);
      // ...
    }
  }
}

// Especializa√ß√£o sem duplica√ß√£o
class PricingEngine extends RulesEngine<PricingRule> {
  // Apenas m√©todos espec√≠ficos de pricing
}
```

#### 4. **Template Method Pattern nas Classes Abstratas**

**Evita Duplica√ß√£o de Algoritmos:**
```dart
abstract class Product extends BaseModel {
  // Template method - algoritmo reutiliz√°vel
  double get totalPrice => calculateTotal(basePrice, quantity); // ‚úÖ DRY
  String get formattedPrice => formatCurrency(totalPrice); // ‚úÖ DRY
  bool get isValid => isValidString(id) && isPositive(basePrice); // ‚úÖ DRY
  
  // M√©todos abstratos - cada produto implementa sua l√≥gica espec√≠fica
  List<FormFieldConfig> getFormFields();
  double calculateBasePrice(Map<String, dynamic> formData);
}
```

#### 5. **Result Pattern para Tratamento de Erros**

**‚ùå ANTES (Tratamento Duplicado):**
```dart
class ProductRepository {
  Future<Product?> findById(String id) async {
    try {
      return _storage[id];
    } catch (e) {
      print('Error: $e'); // Tratamento duplicado
      return null;
    }
  }
}

class BusinessRuleRepository {
  Future<BusinessRule?> findById(String id) async {
    try {
      return _storage[id];
    } catch (e) {
      print('Error: $e'); // DUPLICADO
      return null;
    }
  }
}
```

**‚úÖ DEPOIS (DRY com Result Pattern):**
```dart
abstract class Result<T> {
  // Tratamento centralizado de erros
  Result<T> onFailure(void Function(String error) action) {
    if (isFailure) action((this as Failure<T>).error);
    return this;
  }
  
  Result<R> map<R>(R Function(T data) transform) {
    // Transforma√ß√£o segura sem duplica√ß√£o
  }
}

// Uso consistente em todo o projeto
Future<Result<T>> save(T item) async {
  try {
    _storage[item.id] = item;
    return Result.success(item);
  } catch (e) {
    return Result.failure('Erro ao salvar: $e');
  }
}
```

### üìä M√©tricas de Redu√ß√£o de Duplica√ß√£o

| **Componente** | **Antes (Linhas)** | **Depois (Linhas)** | **Redu√ß√£o** |
|----------------|---------------------|---------------------|-------------|
| Formata√ß√£o/Valida√ß√£o | ~300 (duplicadas) | ~150 (mixins) | **50%** |
| Repository CRUD | ~400 (3 classes) | ~150 (1 gen√©rica) | **62%** |
| Rules Engine | ~600 (3 engines) | ~200 (1 gen√©rica) | **66%** |
| Error Handling | ~200 (espalhado) | ~80 (Result pattern) | **60%** |
| **TOTAL** | **~1500 linhas** | **~580 linhas** | **üéØ 61% redu√ß√£o** |

### üéØ Princ√≠pios DRY Aplicados

1. **Single Source of Truth**: Cada funcionalidade tem 1 implementa√ß√£o
2. **Composition over Inheritance**: Mixins ao inv√©s de heran√ßa m√∫ltipla
3. **Generic Programming**: Uma implementa√ß√£o para m√∫ltiplos tipos
4. **Template Method**: Algoritmos reutiliz√°veis em classes base
5. **Strategy Pattern**: Comportamentos intercambi√°veis sem duplica√ß√£o

### üîç Exemplos de Reutiliza√ß√£o

```dart
// ‚úÖ Todos os produtos usam as mesmas funcionalidades
final industrial = IndustrialProduct(...);
final residential = ResidentialProduct(...);

print(industrial.formattedPrice);    // ‚úÖ FormatterMixin
print(residential.formattedPrice);   // ‚úÖ Mesma implementa√ß√£o

print(industrial.isValid);           // ‚úÖ ValidatorMixin
print(residential.isValid);          // ‚úÖ Mesma implementa√ß√£o

final total1 = industrial.totalPrice;   // ‚úÖ CalculatorMixin
final total2 = residential.totalPrice;  // ‚úÖ Mesma implementa√ß√£o
```

**Resultado:** üéØ **Zero duplica√ß√£o** de c√≥digo entre diferentes tipos de produto!

## üèóÔ∏è Arquitetura

### Estrutura do Projeto

```
lib/
‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îú‚îÄ‚îÄ design/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ app_theme.dart           # Sistema de design e temas
‚îÇ   ‚îú‚îÄ‚îÄ mixins/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ calculator_mixin.dart    # Funcionalidades de c√°lculo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ formatter_mixin.dart     # Formata√ß√£o de dados
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validator_mixin.dart     # Valida√ß√µes comuns
‚îÇ   ‚îî‚îÄ‚îÄ result/
‚îÇ       ‚îî‚îÄ‚îÄ result.dart              # Pattern para tratamento de erros
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îú‚îÄ‚îÄ base/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ base_model.dart          # Modelo base abstrato
‚îÇ   ‚îú‚îÄ‚îÄ products/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product.dart             # Classe abstrata Product (com mixins)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ industrial_product.dart  # Especializa√ß√£o industrial
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ residential_product.dart # Especializa√ß√£o residencial
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ corporate_product.dart   # Especializa√ß√£o corporativa
‚îÇ   ‚îú‚îÄ‚îÄ rules/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ business_rule.dart       # Classe abstrata BusinessRule
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pricing_rule.dart        # Regras de precifica√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validation_rule.dart     # Regras de valida√ß√£o
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ visibility_rule.dart     # Regras de visibilidade
‚îÇ   ‚îî‚îÄ‚îÄ fields/
‚îÇ       ‚îî‚îÄ‚îÄ form_field_config.dart   # Configura√ß√£o de campos din√¢micos
‚îú‚îÄ‚îÄ repositories/
‚îÇ   ‚îú‚îÄ‚îÄ repository.dart              # Interface gen√©rica IRepository<T> com Result Pattern
‚îÇ   ‚îî‚îÄ‚îÄ product_repository.dart      # Repository espec√≠fico para produtos
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ rules_engine.dart            # Engine de regras gen√©rica
‚îÇ   ‚îî‚îÄ‚îÄ rules_service.dart           # Servi√ßo de inicializa√ß√£o de regras
‚îú‚îÄ‚îÄ controllers/
‚îÇ   ‚îú‚îÄ‚îÄ form_controller.dart         # Controller gen√©rico para formul√°rios
‚îÇ   ‚îî‚îÄ‚îÄ budget_controller.dart       # Controller principal
‚îú‚îÄ‚îÄ widgets/
‚îÇ   ‚îú‚îÄ‚îÄ dynamic_form_field.dart      # Factory para campos din√¢micos
‚îÇ   ‚îú‚îÄ‚îÄ dynamic_form_widget.dart     # Widget de formul√°rio din√¢mico
‚îÇ   ‚îú‚îÄ‚îÄ product_selector.dart        # Seletor de produtos
‚îÇ   ‚îú‚îÄ‚îÄ pricing_summary.dart         # Resumo de pre√ßos
‚îÇ   ‚îú‚îÄ‚îÄ unified_form_summary.dart    # Formul√°rio unificado
‚îÇ   ‚îú‚îÄ‚îÄ product_card.dart            # Card de produto
‚îÇ   ‚îú‚îÄ‚îÄ loading_overlay.dart         # Overlay de carregamento
‚îÇ   ‚îî‚îÄ‚îÄ bottom_navigation.dart       # Navega√ß√£o inferior
‚îú‚îÄ‚îÄ screens/
‚îÇ   ‚îî‚îÄ‚îÄ budget_screen.dart           # Tela principal
‚îî‚îÄ‚îÄ main.dart                        # Ponto de entrada da aplica√ß√£o
```

## üöÄ Como Executar

### Pr√©-requisitos

- Flutter SDK 3.8.1 ou superior
- Dart SDK 3.8.1 ou superior

### Instala√ß√£o

1. Clone o reposit√≥rio:
```bash
git clone https://github.com/herverson/altdesafio
cd altdesafaio
```

2. Instale as depend√™ncias:
```bash
flutter pub get
```

3. Execute a aplica√ß√£o:
```bash
flutter run
```

### Testes

Execute os testes unit√°rios:
```bash
flutter test
```

## üì± Fluxos de Teste

### Fluxo Principal

1. **Produto Industrial** ‚Üí Campos espec√≠ficos aparecem ‚Üí Voltagem >220V ‚Üí Certifica√ß√£o obrigat√≥ria
2. **Quantidade 100** ‚Üí Desconto volume aplicado ‚Üí Cliente VIP ‚Üí Desconto adicional
3. **Trocar para Residencial** ‚Üí Formul√°rio reconstr√≥i ‚Üí Regras continuam funcionando

### Demonstra√ß√£o dos Mixins

**Formata√ß√£o:**
```dart
product.formattedPrice        // "R$ 2.616,30"
product.formattedBasePrice    // "R$ 2.500,00"
```

**Valida√ß√£o:**
```dart
product.isValid              // true/false
product.isPositive(price)     // true/false
product.needsCertification(voltage, cert) // true/false
```

**C√°lculos:**
```dart
product.totalPrice           // basePrice * quantity
product.calculateTotal(price, qty) // c√°lculo direto
```

### Cen√°rios de Teste

- **Polimorfismo**: Lista mista de produtos processada via interface `Product`
- **Gen√©ricos**: Repository aceita apenas tipos corretos (erro compila√ß√£o com tipo inv√°lido)
- **DRY**: Valida√ß√µes similares n√£o duplicadas, c√°lculos centralizados via mixins
- **Result Pattern**: Opera√ß√µes retornam `Result<T>` para tratamento de erros
- **Mixins**: Funcionalidades transversais reutilizadas em todos os produtos

## üîß Padr√µes de Design Utilizados

- **Strategy Pattern**: Engine de regras intercambi√°veis
- **Factory Pattern**: Cria√ß√£o de widgets din√¢micos
- **Repository Pattern**: Acesso a dados type-safe com Result Pattern
- **Observer Pattern**: Controllers reativos
- **Template Method**: Algoritmos reutiliz√°veis
- **Composition over Inheritance**: Componentiza√ß√£o + Mixins
- **Result Pattern**: Tratamento robusto de erros
- **Mixin Pattern**: Funcionalidades transversais reutiliz√°veis

## üìä Benef√≠cios da Arquitetura

- **Escalabilidade**: F√°cil adi√ß√£o de novos tipos de produtos e regras
- **Manutenibilidade**: C√≥digo organizado, limpo e bem estruturado
- **Reutiliza√ß√£o**: Mixins e componentes gen√©ricos aplic√°veis a diferentes cen√°rios
- **Robustez**: Result Pattern para tratamento consistente de erros
- **Testabilidade**: Arquitetura facilita testes unit√°rios e de integra√ß√£o
- **Performance**: Otimiza√ß√µes para evitar rebuilds desnecess√°rios
- **DRY**: Funcionalidades comuns centralizadas em mixins

## üé® Interface

- **Design Responsivo**: Adapt√°vel a diferentes tamanhos de tela
- **UX Fluida**: Transi√ß√µes suaves e feedback adequado
- **Visual Moderno**: Material Design 3
- **Acessibilidade**: Componentes acess√≠veis
- **Formata√ß√£o Consistente**: Mixins garantem formata√ß√£o uniforme

## üßπ Otimiza√ß√µes Aplicadas

### Limpeza de C√≥digo
- ‚úÖ Removidos 10 arquivos n√£o utilizados (~800 linhas)
- ‚úÖ Estrutura simplificada e organizada
- ‚úÖ Foco apenas no c√≥digo necess√°rio

### Melhorias Implementadas
- ‚úÖ **Mixins**: Funcionalidades transversais reutiliz√°veis
- ‚úÖ **Result Pattern**: Tratamento robusto de erros
- ‚úÖ **Arquitetura Limpa**: C√≥digo organizado e manuten√≠vel

## üîç Status do Projeto

| Componente | Status | Observa√ß√µes |
|------------|--------|-------------|
| Mixins | ‚úÖ Funcionais | Integrados nos produtos |
| Result Pattern | ‚úÖ Funcionais | Usado no repository/controller |
| Repository | ‚úÖ Funcionais | Com Result Pattern |
| Engine de Regras | ‚úÖ Funcionais | Completa e testada |
| Formul√°rio Din√¢mico | ‚úÖ Funcionais | Responsivo e validado |
| Testes | ‚úÖ Funcionais | Completa |

---

<img width="390" height="864" alt="Screenshot 2025-08-23 021908" src="https://github.com/user-attachments/assets/cb3c528c-7285-4b65-b5f7-252222ca4e22" />
<img width="390" height="861" alt="Screenshot 2025-08-23 021807" src="https://github.com/user-attachments/assets/16c20dda-a3ac-415f-a25d-ba3823cdf2d6" />
<img width="390" height="864" alt="Screenshot 2025-08-23 021742" src="https://github.com/user-attachments/assets/19f36ec1-4197-4825-b1ce-089ca20ceef7" />
<img width="390" height="857" alt="Screenshot 2025-08-23 021919" src="https://github.com/user-attachments/assets/2b12cbf6-6c6d-4e1b-ac45-0d261bc90d08" />


**Desenvolvido por**: Herverson de Sousa  
**Framework**: Flutter 3.8.1  
**Linguagem**: Dart 3.8.1  

**√öltima Atualiza√ß√£o**: Agosto 2025
